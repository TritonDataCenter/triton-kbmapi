/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2019 Joyent, Inc.
 */

/*
 * Unit tests for pivtoken endpoints
 */

'use strict';

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const util = require('util');

const h = require('../helpers');
const mod_jsprim = require('jsprim');
const mod_token = require('../../lib/token');
const mod_server = require('../../lib/server');
const test = require('tape');

const eboxTpl = fs.readFileSync(path.resolve(
    __dirname, '../../fixtures/backup'), 'ascii');

const anotherTpl = fs.readFileSync(path.resolve(
    __dirname, '../../fixtures/another'), 'ascii');

var KBMAPI;
var MORAY;
var CLIENT;
var RECOVERY_CONFIG;
var ANOTHER_CONFIG;
var REC_TOKEN;
// Values here were generated by reading /dev/random. Any resemblance to
// actual pivtokens, living or dead, is purely coincidential.  Sorted by GUID
var TOKENS = [
    {
        guid: '75CA077A14C5E45037D7A0740D5602A5',
        pin: '12345',
        serial: 'abcd12345',
        model: 'ACME insta-token model 1',
        cn_uuid: '00000000-0000-0000-0000-000000000001',
        pubkeys: {
            /* eslint-disable max-len */
            '9a': 'ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBC7NhJvp9c5XMOkPLfDvsHZytnY4cWduFRF4KlQIr7LNQnbw50NNlbyhXHzD85KjcztyMoqn9w4XuHdJh4O1lH4=',
            '9d': 'ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBD+uKKyn5tBNziW21yPt/0FE2LD4l1cWgzONYjn3n8BzSNo/aTzJccki7Q/Lyk7dM8yZLAc/5V/U/QHbLTpexBg=',
            '9e': fs.readFileSync(path.resolve(__dirname, '../../fixtures/one_token_test_edcsa.pub'), 'ascii')
            /* eslint-enable max-len */
        }
    },
    {
        guid: 'DDA81AA0DB3528479AB6D2AC75624E5E',
        pin: '54321',
        serial: 'deadbeef123',
        model: 'ACME insta-token model 1',
        cn_uuid: '00000000-0000-0000-0000-000000000002',
        pubkeys: {
            /* eslint-disable max-len */
            '9a': 'ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEv/A+0Gc6X5fADdewP1+VJvqgq+ANVCA9rLHxvVkbqbDeFoUBFIPBqKBmpw6kWMb4J6B+4oQTp936+CgdJySz8=',
            '9d': 'ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFD+ANQt5yC9EvPa5V7OfFpscRDbN9e+ghc0g+u6wVA4CQw1+/s4NRUybf/HIOveYHfpiP9ai5C6HAZYQE28rNY=',
            '9e': fs.readFileSync(path.resolve(__dirname, '../../fixtures/another_token_test_edcsa.pub'), 'ascii')
            /* eslint-enable max-len */
        }
    }
];

var OTHER_TOKEN = {
    model: 'Yubico Yubikey 4',
    serial: 6324923,
    cn_uuid: '00000000-0000-0000-0000-000000000002',
    guid: '1FFCFCBF0BE44E30975A550069B9B741',
    pin: '424242',
    pubkeys: {
            /* eslint-disable max-len */
            '9a': 'ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEv/A+0Gc6X5fADdewP1+VJvqgq+ANVCA9rLHxvVkbqbDeFoUBFIPBqKBmpw6kWMb4J6B+4oQTp936+CgdJySz8=',
            '9d': 'ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFD+ANQt5yC9EvPa5V7OfFpscRDbN9e+ghc0g+u6wVA4CQw1+/s4NRUybf/HIOveYHfpiP9ai5C6HAZYQE28rNY=',
            '9e': fs.readFileSync(path.resolve(__dirname, '../../fixtures/another_token_recovery_edcsa.pub'), 'ascii')
            /* eslint-enable max-len */
    }
};

var RECOVERY_TOKEN;

var privKeys = [
    fs.readFileSync(path.resolve(__dirname,
        '../../fixtures/one_token_test_edcsa'),
        'ascii'),
    fs.readFileSync(path.resolve(__dirname,
        '../../fixtures/another_token_test_edcsa'),
        'ascii')
];

test('Initial setup', function tInitialSetup(suite) {
    h.reset();

    suite.test('Create client and server', function tCreateClientServer(t) {
        h.createClientAndServer(function (err, client, moray, server) {
            KBMAPI = server;
            MORAY = moray;
            CLIENT = client;
            t.ifError(err, 'server creation');
            t.ok(KBMAPI, 'server');
            t.ok(MORAY, 'moray');
            t.ok(CLIENT, 'client');
            t.end();
        });
    });


    suite.test('Create RecoveryConfiguration', function doCreate(t) {
        CLIENT.clean();
        CLIENT.createRecoveryConfiguration({
            template: eboxTpl
        }, function createCb(err, recoveryConfig, res) {
            t.ifError(err, 'create recovery configuration error');
            t.ok(recoveryConfig, 'recoveryConfig');
            t.ok(recoveryConfig.uuid, 'recoveryConfig UUID');
            t.ok(recoveryConfig.created, 'recoveryConfig created');
            RECOVERY_CONFIG = recoveryConfig;
            t.equal(res.statusCode, 201, 'create rec-cfg response code');
            t.end();
        });
    });


    suite.test('Create Another RecoveryConfiguration', function doCreate(t) {
        CLIENT.clean();
        CLIENT.createRecoveryConfiguration({
            template: anotherTpl
        }, function createCb(err, recoveryConfig, res) {
            t.ifError(err, 'create recovery configuration error');
            t.ok(recoveryConfig, 'recoveryConfig');
            t.ok(recoveryConfig.uuid, 'recoveryConfig UUID');
            t.ok(recoveryConfig.created, 'recoveryConfig created');
            ANOTHER_CONFIG = recoveryConfig;
            t.equal(res.statusCode, 201, 'create rec-cfg response code');
            t.end();
        });
    });

    suite.test('Create pivtoken w/o cn_uuid', function tCreateWOCNUuid(t) {
        CLIENT.clean();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        delete tk.cn_uuid;
        mod_token.create(t, {
            params: tk,
            expErr: {
                code: 'InvalidParameters',
                message: 'Missing parameters',
                errors: [ {
                    field: 'cn_uuid',
                    code: 'MissingParameter',
                    message: 'Missing parameter'
                } ]
            },
            expCode: 422,
            privkey: privKeys[0]
        });
    });

    suite.test('Create pivtoken w/o pin', function tCreateWOPin(t) {
        CLIENT.clean();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        delete tk.pin;
        mod_token.create(t, {
            params: tk,
            expErr: {
                code: 'InvalidParameters',
                message: 'Missing parameters',
                errors: [ {
                    field: 'pin',
                    code: 'MissingParameter',
                    message: 'Missing parameter'
                } ]
            },
            expCode: 422,
            privkey: privKeys[0]
        });
    });

    suite.test('Create pivtoken invalid pubkeys', function tInvalidKeys(t) {
        CLIENT.clean();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        tk.pubkeys['9a'] = null;
        mod_token.create(t, {
            params: tk,
            expErr: {
                code: 'InvalidParameters',
                message: 'Invalid parameters',
                errors: [ {
                    field: 'pubkeys.9a',
                    code: 'InvalidParameter',
                    message: 'must be a string'
                } ]
            },
            expCode: 422,
            privkey: privKeys[0]
        });
    });

    suite.test('Create pivtoken invalid recovery cfg', function tWrongCfg(t) {
        CLIENT.clean();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        tk.recovery_configuration = '00000000-0000-0000-0000-000000000001';
        mod_token.create(t, {
            params: tk,
            expErr: {
                code: 'InvalidParameters',
                message: 'invalid recovery_configuration parameter',
                errors: [ {
                    field: 'recovery_configuration',
                    code: 'InvalidParameter',
                    message: 'cannot create a PIVToken without a valid ' +
                        'recovery configuration'
                } ]
            },
            expCode: 422,
            privkey: privKeys[0]
        });
    });

    suite.test('Create pivtokens', function tCreateTokens(t) {
        CLIENT.clean();
        function createAToken(aToken, aKey) {
            t.test('Create token GUID ' + aToken.guid, function doCreate(t3) {
                mod_token.create(t3, {
                    params: Object.assign({}, aToken, {
                        recovery_configuration: RECOVERY_CONFIG.uuid
                    }),
                    exp: aToken,
                    privkey: aKey
                });
            });
        }
        var i;
        for (i = 0; i < TOKENS.length; i += 1) {
            createAToken(TOKENS[i], privKeys[i]);
        }
        t.end();
    });

    suite.test('Create pivtoken with invalid privkey', function privKeyErr(t) {
        CLIENT.clean();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        mod_token.create(t, {
            params: tk,
            expErr: {
                code: 'InvalidCredentials',
                message: 'Invalid authorization credentials supplied'
            },
            expCode: 401,
            privkey: privKeys[1]
        });
    });

    suite.test('Re-create pivtoken with valid privkey', function privKeyOk(t) {
        CLIENT.clean();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        mod_token.create(t, {
            params: Object.assign({}, tk, {
                recovery_configuration: RECOVERY_CONFIG.uuid
            }),
            exp: tk,
            privkey: privKeys[0]
        });
    });

    suite.test('Re-create pivtoken with different recovery config',
        function differentCfgCb(t) {
        CLIENT.clean();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        delete tk.recovery_tokens[0].template;
        mod_token.create(t, {
            params: Object.assign({}, tk, {
                recovery_configuration: ANOTHER_CONFIG.uuid
            }),
            expCode: 200,
            partialExp: {
                guid: tk.guid
            },
            privkey: privKeys[0]
        }, function (_err, pivtk, _res) {
            t.equal(2, pivtk.recovery_tokens.length,
                'New recovery token created');
            t.end();
        });
    });

    suite.test('Get pivtoken', function tGetToken(t) {
        CLIENT.clean();
        var tok = TOKENS[0];

        mod_token.get(t, {
            params: {
                guid: tok.guid
            },
            exp: {
                guid: tok.guid,
                serial: tok.serial,
                cn_uuid: tok.cn_uuid,
                model: tok.model,
                pubkeys: tok.pubkeys
            },
            fillIn: ['recovery_tokens']
        });
    });


    suite.test('Get pivtoken with pin requires auth', function tGetTkPin(t) {
        CLIENT.clean();
        var tok = TOKENS[0];

        mod_token.getPin(t, {
            params: {
                guid: tok.guid
            },
            expErr: {
                code: 'InvalidCredentials',
                message: 'You must make authenticated requests to use KBMAPI'
            },
            expCode: 401
        });
    });

    suite.test('Get pivtoken with pin', function tGetTokenPin(t) {
        CLIENT.clean();
        var tok = TOKENS[1];

        mod_token.getPin(t, {
            params: {
                guid: tok.guid
            },
            privkey: privKeys[1],
            pubkey: TOKENS[1].pubkeys['9e'],
            exp: tok
        }, function getPinCb(_err, token, _res) {
            t.ok(token.recovery_tokens[0].token, 'Recover token');
            RECOVERY_TOKEN = token.recovery_tokens[0].token;
            t.end();
        });
    });

    suite.test('List pivtokens', function tListTokens(t) {
        CLIENT.clean();
        var tokens = mod_jsprim.deepCopy(TOKENS);

        tokens.forEach(function stripPin(tok) {
            delete tok.pin;
        });

        mod_token.list(t, {
            params: {},
            deepEqual: true,
            present: tokens
        }, function listCb(_err, body) {
            t.ok(body, 'List pivtokens body');
            t.ok(Array.isArray(body), 'array of pivtokens');
            t.ok(Array.isArray(body[0].recovery_tokens),
                'array of recovery tokens');
            var rTks = body[0].recovery_tokens;
            rTks.forEach(function (r) {
                t.ok(typeof r.token === 'undefined',
                    'Token is a sensitive field');
            });
            t.end();
        });
    });

    suite.test('List recovery tokens requires auth', function (t) {
        CLIENT.clean();
        CLIENT.listRecoveryTokens({
            guid: TOKENS[0].guid
        }, function listCb(err, rTks, res) {
            t.ok(err, 'List recovery tokens auth error');
            t.equal(401, res.statusCode, 'not athorized to ls rec tokens');
            t.equal('InvalidCredentials', rTks.code, 'Error body');
            t.end();
        });
    });

    suite.test('List recovery tokens', function (t) {
        CLIENT.clean();
        CLIENT.listRecoveryTokens({
            guid: TOKENS[0].guid,
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e']
        }, function listCb(err, rTks, res) {
            t.ifError(err, 'ls recovery tokens err');
            t.ok(rTks, 'recovery tokens list');
            t.equal(200, res.statusCode, 'ls rec tokens status');
            t.end();
        });
    });

    suite.test('Create recovery token', function (t) {
        CLIENT.clean();
        CLIENT.createRecoveryToken({
            guid: TOKENS[0].guid,
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e']
        }, function createCb(err, rtk, res) {
            t.ifError(err, 'Create recovery token error');
            t.equal(201, res.statusCode, 'Create recovery token status');
            t.ok(rtk, 'Recovery token created');
            REC_TOKEN = rtk;
            t.end();
        });
    });

    suite.test('Get recovery token', function (t) {
        CLIENT.clean();
        CLIENT.getRecoveryToken({
            guid: TOKENS[0].guid,
            uuid: REC_TOKEN.uuid,
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e']
        }, function (err, rtk, res) {
            t.ifError(err, 'Get recovery token error');
            t.equal(200, res.statusCode, 'Get recovery token status');
            t.ok(rtk, 'Get recovery token response body');
            t.end();
        });
    });

    suite.test('Update recovery token', function (t) {
        CLIENT.clean();
        CLIENT.updateRecoveryToken({
            guid: TOKENS[0].guid,
            uuid: REC_TOKEN.uuid,
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e'],
            params: {
                staged: new Date().toISOString(),
                activated: new Date().toISOString()
            }
        }, function (err, rtk, res) {
            t.ifError(err, 'update recovery token err');
            t.equal(200, res.statusCode, 'update recovery token status');
            t.ok(rtk, 'update recovery token response');
            t.ok(rtk.activated, 'activated ok');
            t.ok(rtk.staged, 'staged ok');
            t.end();
        });
    });

    suite.test('Verify Recovery tokens have been expired', function (t) {
        CLIENT.clean();
        CLIENT.getTokenPin({
            guid: TOKENS[0].guid,
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e']
        }, function (err, pivtoken, res) {
            t.ifError(err, 'verify pivtoken error');
            t.equal(200, res.statusCode, 'verify pivtoken status');
            t.ok(pivtoken.recovery_tokens, 'verify pivtoken tokens');
            t.equal(3, pivtoken.recovery_tokens.length, 'tokens length');
            t.ok(pivtoken.recovery_tokens[0].expired, 'old token expired');
            t.ok(pivtoken.recovery_tokens[1].expired, 'old token expired');
            t.notOk(pivtoken.recovery_tokens[2].expired,
                'new token not expired');
            t.end();
        });
    });

    suite.test('Delete recovery token', function (t) {
        CLIENT.clean();
        CLIENT.deleteRecoveryToken({
            guid: TOKENS[0].guid,
            uuid: REC_TOKEN.uuid,
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e']
        }, function (err, res) {
            t.ifError(err, 'delete recovery token error');
            t.equal(204, res.statusCode, 'del rec token status');
            t.end();
        });
    });


    suite.test('Create another recovery token', function (t) {
        CLIENT.clean();
        CLIENT.createRecoveryToken({
            guid: TOKENS[0].guid,
            params: {
                recovery_configuration: RECOVERY_CONFIG.uuid
            },
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e']
        }, function createCb(err, rtk, res) {
            t.ifError(err, 'Create recovery token error');
            t.equal(201, res.statusCode, 'Create recovery token status');
            t.ok(rtk, 'Recovery token created');
            t.notOk(rtk.staged, 'new token should not be staged');
            REC_TOKEN = rtk;
            t.end();
        });
    });

    suite.test('Update recovery tokens (stage)', function (t) {
        CLIENT.clean();
        // This is intentionally ignored at the client level, since it should
        // be used from kbmadm, not kbmctl.
        CLIENT.client.put({
            path: util.format('/pivtokens/%s/recovery-tokens', TOKENS[0].guid)
        }, {
            zpool_recovery: {
                staged: RECOVERY_CONFIG.uuid
            },
            recovery_token: REC_TOKEN.uuid
        }, function putCb(putErr, _req, putRes, _body) {
            t.ifError(putErr, 'update tokens error');
            t.equal(200, putRes.statusCode, 'expected success response');

            CLIENT.listRecoveryTokens({
                guid: TOKENS[0].guid,
                privkey: privKeys[0],
                pubkey: TOKENS[0].pubkeys['9e']
            }, function listCb(err, rTks, res) {
                t.ifError(err, 'ls recovery tokens err');
                t.ok(rTks, 'recovery tokens list');
                t.equal(200, res.statusCode, 'ls rec tokens status');
                var latest = rTks.pop();
                t.ok(latest.staged, 'Token has been staged');
                t.end();
            });
        });
    });

    suite.test('Update recovery tokens (activate)', function (t) {
        CLIENT.clean();
        // This is intentionally ignored at the client level, since it should
        // be used from kbmadm, not kbmctl.
        CLIENT.client.put({
            path: util.format('/pivtokens/%s/recovery-tokens', TOKENS[0].guid)
        }, {
            zpool_recovery: {
                staged: RECOVERY_CONFIG.uuid,
                active: RECOVERY_CONFIG.uuid
            },
            recovery_token: REC_TOKEN.uuid
        }, function putCb(putErr, _req, putRes, _body) {
            t.ifError(putErr, 'update tokens error');
            t.equal(200, putRes.statusCode, 'expected success response');

            CLIENT.listRecoveryTokens({
                guid: TOKENS[0].guid,
                privkey: privKeys[0],
                pubkey: TOKENS[0].pubkeys['9e']
            }, function listCb(err, rTks, res) {
                t.ifError(err, 'ls recovery tokens err');
                t.ok(rTks, 'recovery tokens list');
                t.equal(200, res.statusCode, 'ls rec tokens status');
                var latest = rTks.pop();
                t.ok(latest.activated, 'Token has been activated');
                t.end();
            });
        });
    });
    suite.test('Delete pivtoken requires auth', function tDelTkAuthRequired(t) {
        CLIENT.clean();
        mod_token.delete(t, {
            params: TOKENS[0],
            expErr: {
                code: 'InvalidCredentials',
                message: 'You must make authenticated requests to use KBMAPI'
            },
            expCode: 401
        });
    });

    suite.test('Delete pivtoken', function tDeleteToken(t) {
        CLIENT.clean();
        mod_token.delete(t, {
            params: TOKENS[0],
            privkey: privKeys[0],
            pubkey: TOKENS[0].pubkeys['9e'],
            exp: {}
        });
    });

    suite.test('Lookup deleted pivtoken', function tGetDeletedToken(t) {
        CLIENT.clean();
        mod_token.get(t, {
            params: {
                guid: TOKENS[0].guid
            },
            expCode: 404,
            expErr: {
                code: 'ResourceNotFound',
                message: 'piv tokens not found'
            }
        });
    });

    suite.test('pivy-tool', function pivyCb(t) {
        CLIENT.clean();
        var res;
        const cp = require('child_process');
        try {
            res = cp.execSync('which pivy-tool');
        } catch (error) {
            console.log(error);
            t.comment('Skipping tests b/c `which pivy-tool` cmd failed');
            t.end();
            return;
        }

        const pivytool = res.toString().trim();
        const _9ecmd = util.format('%s pubkey 9e', pivytool);
        try {
            res = cp.execSync(_9ecmd);
        } catch (err2) {
            console.log(err2);
            t.comment('Skipping tests b/c ' + _9ecmd + ' failed');
            t.end();
            return;
        }

        const pubkey = res.toString().trim();
        var tk = mod_jsprim.deepCopy(TOKENS[0]);
        tk.guid = '0F4FE4B9EF0C46FC89DA79B38A61A1A1';
        tk.cn_uuid = '00000000-0000-0000-0000-000000000003';
        tk.pubkeys['9e'] = pubkey;
        delete tk.recovery_tokens;

        CLIENT.createToken({
            guid: tk.guid,
            token: Object.assign({}, tk, {
                recovery_configuration: RECOVERY_CONFIG.uuid
            }),
            pivytool: pivytool
        }, function createTkCb(err, body, response) {
            t.ifError(err, 'create token err');
            t.equal(response.statusCode, 201, 'create token response code');
            t.ok(body, 'create token body');
            delete body.recovery_tokens;
            t.deepEqual(body, tk, 'body expected to be equal to given token');

            CLIENT.createToken({
                guid: tk.guid,
                token: Object.assign({}, tk, {
                    recovery_configuration: RECOVERY_CONFIG.uuid
                }),
                pivytool: pivytool
            }, function reCreateTkCb(err2, body2, response2) {
                t.ifError(err2, 'create token pivy signed err');
                t.ok(body2.recovery_tokens, 'missing recovery_tokens');
                tk.recovery_tokens = body2.recovery_tokens;
                t.deepEqual(body2, tk, 'body  expected to be equal to token');
                t.equal(response2.statusCode, 200, 'create token resp code');
                CLIENT.getTokenPin({
                    guid: tk.guid,
                    pivytool: pivytool
                }, function getTkPinCb(getErr, getBody, getResponse) {
                    t.ifError(getErr, 'getTokenPIN PIVY error');
                    t.ok(getBody.recovery_tokens, 'getTokenPIN tokens');
                    t.equal(getResponse.statusCode, 200, 'getTokenPIN status');
                    t.end();
                });
            });
        });
    });

    suite.test('replace pivtoken needs HMAC auth', function replaceToken401(t) {
        CLIENT.clean();
        mod_token.recover(t, {
            params: {
                guid: TOKENS[1].guid,
                recovery_token: crypto.randomBytes(40).toString('hex'),
                token: OTHER_TOKEN
            },
            expErr: {
                code: 'InvalidCredentials',
                message: 'Invalid authorization credentials supplied'
            },
            expCode: 401
        });
    });

    suite.test('replace pivtoken', function replacePivToken(t) {
        CLIENT.clean();
        mod_token.recover(t, {
            params: {
                guid: TOKENS[1].guid,
                recovery_token: RECOVERY_TOKEN,
                token: Object.assign({}, OTHER_TOKEN, {
                    recovery_configuration: RECOVERY_CONFIG.uuid
                })
            },
            exp: OTHER_TOKEN
        });
    });

    suite.test('Get pivtoken PIN with admin key', function (t) {
        CLIENT.clean();
        const privkey = path.resolve(__dirname, '../../../etc/sdc_key');
        if (!fs.existsSync(privkey)) {
            t.comment('No SDC public/private key files found');
            t.end();
            return;
        }

        CLIENT.getTokenPin({
            guid: '0F4FE4B9EF0C46FC89DA79B38A61A1A1',
            pubkey: fs.readFileSync(privkey + '.pub', 'ascii'),
            privkey: fs.readFileSync(privkey, 'ascii')
        }, function getTkPinCb(getErr, getBody, getResponse) {
            t.ifError(getErr, 'getTokenPIN admin key error');
            t.ok(getBody.recovery_tokens, 'getTokenPIN admin key tokens');
            t.equal(getResponse.statusCode, 200, 'getTokenPIN admin key code');
            t.end();
        });
    });

    suite.test('Get pivtoken PIN with invalid admin key', function (t) {
        CLIENT.clean();
        CLIENT.getTokenPin({
            guid: '0F4FE4B9EF0C46FC89DA79B38A61A1A1',
            pubkey: fs.readFileSync(path.resolve(__dirname,
                    '../../fixtures/one_token_test_edcsa.pub'), 'ascii'),
            privkey: fs.readFileSync(path.resolve(__dirname,
                    '../../fixtures/one_token_test_edcsa'), 'ascii')
        }, function getTkPinCb(getErr, _getBody, getResponse) {
            t.ok(getErr, 'expected error when trying to use non admin key');
            t.equal(getResponse.statusCode, 401, 'getTokenPIN admin key code');
            t.end();
        });
    });
});

test('Stop server', function closeServers(t) {
    KBMAPI.server.close();
    mod_server.close(t);
});

// vim: set softtabstop=4 shiftwidth=4:
